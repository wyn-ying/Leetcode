###idea
看完题干，很自然想到对每个数求1的个数。但补充要求指出不要O(n*sizeof(integer))，要O(n)复杂度，因此考虑用DP方法。
对于一个数i，它的二进制中1的数量，可以看成是最后一位（奇为1，偶为0）加上前面的数。而前面的数正好是```i<<1```的1的个数。
因此可以构建递推关系
```python
r[i] = (r[i>>1] if i%2 == 0 else r[i>>1]+1)
```

###solutions
为了达到O(n)，都是用了DP方法，思路一样。

不过在答案区找到一种更为简洁的表达形式
```python
r[i] = r[i&(i-1)] + 1
```
避免了分支条件而直接用&运算使得算法执行时间大幅减少。

###time consuming
#####my solution
216ms-->beats 50.55%
#####discuss solution
176ms-->beats 98.50%